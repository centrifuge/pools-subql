type Timekeeper @entity {
  id: ID!
  lastPeriodStart: Date!
}

type Pool @entity {
  id: ID!

  # It's not possible to simply retrieve all entities, but it is supported
  # to get all entities by a field. Hence we add the same type field to all
  # pools, so we can do Pool.getByType("POOL").
  type: String! @index

  createdAt: Date!
  createdAtBlockNumber: Int!

  currency: String!
  metadata: String!

  minEpochTime: Int!
  maxNavAge: Int!

  # This cannot reference Pool directly, since this leads to a cyclic dependency.
  currentEpoch: Int!
  lastEpochClosed: Int
  lastEpochExecuted: Int

  state: PoolState!

  tranches: [Tranche] @derivedFrom(field: "pool")
}

# Track current state that regularly changes
type PoolState @entity {
  id: ID! #poolId
  type: String! @index
  #States
  netAssetValue: BigInt!
  totalReserve: BigInt!
  availableReserve: BigInt!
  maxReserve: BigInt!
  totalDebt: BigInt!

  tranches: [Tranche] @derivedFrom(field: "pool")
}
#Tracks PoolState over Time
type PoolSnapshot @entity {
  id: ID! #poolId-blockHeight
  pool: Pool!

  timestamp: Date!
  blockNumber: Int!

  #States
  netAssetValue: BigInt!
  totalReserve: BigInt!
  availableReserve: BigInt!
  maxReserve: BigInt!
  totalDebt: BigInt!

  # Aggregated transaction data over the last period
  totalBorrowed: BigInt
  totalRepaid: BigInt
  totalInvested: BigInt
  totalRedeemed: BigInt
}

type Tranche @entity {
  id: ID! #poolId-index
  type: String! @index
  pool: Pool! @index

  # id cannot be the tranche id as it's not globally unique, so we store it separately
  trancheId: String!

  isResidual: Boolean!
  seniority: Int!
  interestRatePerSec: BigInt
  minRiskBuffer: BigInt

  state: TrancheState!
}

type TrancheState @entity {
  id: ID! #poolId-index
  type: String! @index
  supply: BigInt
  price: Float

  outstandingInvestOrders: BigInt
  outstandingRedeemOrders: BigInt

  yield30Days: BigInt
  yield90Days: BigInt
  yieldSinceInception: BigInt
}

type TrancheSnapshot @entity {
  id: ID! #poolId-index-blockheight
  tranche: Tranche!

  timestamp: Date!
  blockNumber: Int!

  supply: BigInt
  price: Float

  outstandingInvestOrders: BigInt
  outstandingRedeemOrders: BigInt

  yield30Days: BigInt
  yield90Days: BigInt
  yieldSinceInception: BigInt
}

type Epoch @entity {
  id: ID! #poolId-index
  pool: Pool!

  index: Int!

  openedAt: Date
  closedAt: Date
  executedAt: Date

  # openPoolState: PoolState!
  # closePoolState: PoolState
  # executePoolState: PoolState

  investorTransactions: [InvestorTransaction] @derivedFrom(field: "epoch")
  borrowerActions: [BorrowerTransaction] @derivedFrom(field: "epoch")

  # Aggregated data during this epoch
  totalBorrowed: BigInt
  totalRepaid: BigInt
  totalInvested: BigInt
  totalRedeemed: BigInt
}

enum InvestorTransactionType {
  INVEST_ORDER_UPDATE
  REDEEM_ORDER_UPDATE
  INVEST_ORDER_CANCEL
  REDEEM_ORDER_CANCEL
  INVEST_EXECUTION
  REDEEM_EXECUTION
  TRANSFER_IN
  TRANSFER_OUT
}

type InvestorTransaction @entity {
  id: ID! # transaction hash
  account: Account @index
  pool: Pool! @index
  tranche: Tranche! @index
  epoch: Epoch! @index
  timestamp: Date!
  type: InvestorTransactionType!
  tokenAmount: BigInt
  currencyAmount: BigInt
  tokenPrice: BigInt
  transactionFee: BigInt
}

#UNUSED
type OutstandingOrder @entity {
  id: ID! # pool id - tranche id - investor address
  account: Account @index
  pool: Pool! @index
  tranche: Tranche! @index

  invest: BigInt!
  redeem: BigInt!
  epoch: Epoch @index
}

type Account @entity {
  id: ID!

  publicAddress: String!
}

type AccountBalance @entity {
  id: ID! # pool id - tranche id - account id
  account: Account @index
  pool: Pool! @index
  tranche: Tranche! @index

  collected: BigInt!
  uncollected: BigInt!
  ordered: BigInt!
}

enum LoanStatus {
  CREATED
  ACTIVE
  CLOSED
}

#UNUSED
type Loan @entity {
  id: ID!

  createdAt: Date!

  # collateral:
  status: LoanStatus!
  # TODO: how to store loan type data

  interestRatePerSec: BigInt
  outstandingDebt: BigInt

  writeOffIndex: Int
  adminWrittenOff: Boolean

  pool: Pool!
}

enum BorrowerTransactionType {
  CREATED
  PRICED
  BORROWED
  REPAID
  CLOSED
}

#UNUSED
type BorrowerTransaction @entity {
  id: ID!

  account: Account!
  epoch: Epoch!
  loan: Loan!
  type: BorrowerTransactionType!

  # only applies to BORROWED and REPAID transactions
  amount: BigInt 
}

type AnonymousProxy @entity {
  id: ID!

  account: String!
  createdBy: String!
  proxyType: String
}

type Proxy @entity {
  id: ID!

  delegator: String!
  delegatee: String!
  proxyType: String
  removed: Boolean
  delay: Int
}

